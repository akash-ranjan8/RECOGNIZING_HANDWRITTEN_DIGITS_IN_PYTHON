# -*- coding: utf-8 -*-
"""recognizing_digits.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y5mzQEJ8X9Wq2oy0nB2eylQVRUpojfRr

#RECOGNIZING THE HANDWRITTEN DIGITS

#IMPORTING THE LIBRARIES
"""

# Commented out IPython magic to ensure Python compatibility.
from sklearn.datasets import fetch_openml
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn import metrics
import numpy as np
import matplotlib.pyplot as plt

# %matplotlib inline

"""#EXTRACTING THE DATA"""

mnist = fetch_openml("mnist_784")

"""#PLOTTING THE DATASET DIGITS"""

plt.figure(figsize=(20,4))
for index,(image,label) in enumerate(zip(mnist.data[:5],mnist.target[:5])):
    plt.subplot(1,5,index+1)
    plt.imshow(np.reshape(image,(28,28)),cmap="gray")
    plt.title("Number: %s" % label)

"""#SPLITTING THE DATASET"""

X_train,X_test,Y_train,Y_test = train_test_split(mnist.data,mnist.target,test_size=0.2)

"""#APPLYING THE LOGISTIC REGRESSION ON THE TRAINING SET"""

mdl = LogisticRegression(solver='lbfgs')
mdl.fit(X_train,Y_train)
predictions = mdl.predict(X_test)
score = mdl.score(X_test,Y_test)
print(score)

"""#PREDICTIONS OF DIGITS"""

index=1
plt.imshow(np.reshape(X_test[index],(28,28)))
print("Prediction: "+mdl.predict([X_test[index]])[0])

index=2
plt.imshow(np.reshape(X_test[index],(28,28)))
print("Prediction: "+mdl.predict([X_test[index]])[0])

index=4
plt.imshow(np.reshape(X_test[index],(28,28)))
print("Prediction: "+mdl.predict([X_test[index]])[0])

index=7
plt.imshow(np.reshape(X_test[index],(28,28)))
print("Prediction: "+mdl.predict([X_test[index]])[0])

index=13
plt.imshow(np.reshape(X_test[index],(28,28)))
print("Prediction: "+mdl.predict([X_test[index]])[0])

"""#MAKING CONFUSION MATRIX"""

cm = metrics.confusion_matrix(Y_test,predictions)
print(cm)

plt.figure(figsize=(8,8))
plt.imshow(cm,cmap='Accent')
plt.title('Confusion Matrix For MNIST Data')

plt.xticks(np.arange(10))
plt.yticks(np.arange(10))

plt.colorbar()

plt.ylabel('Actual Label')
plt.xlabel('Predicted Label')

width,height = cm.shape
for x in range(width):
    for y in range(height):
        plt.annotate(str(cm[x][y]),xy=(y,x),horizontalalignment="center",verticalalignment="center")